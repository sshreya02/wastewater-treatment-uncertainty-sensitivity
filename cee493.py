# -*- coding: utf-8 -*-
"""CEE493.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Xav7tuPl4eeq9OjrnQgfMcMNRbWvq7PA
"""

import math as mt
from math import pi as pi
import matplotlib.pyplot as plt
import numpy as np

# Design combinations for DO, WAS, Q_methanol from GPS-X
MLE_design_comb = [(2, 3232.74, 19), (1.6, 2800., 20), (1.8, 2500., 16)]
Bardenpho_design_comb = [(2, 3232.74, 19), (1.6, 2800., 20), (1.8, 2500., 16)]

# DO = 2 # Dissolved oxygen concentration in mg/L from GPS-X.
# WAS = 3232.74 # Waste activated sludge flowrate or wastage rate, m3/day.
# Q_methanol = 20.0 # Flow rate of methanol obtained from GPS-X, m3/day.

# Influent wastewater characteristics
Q = 85.4 * 3785.4118 # MGD to m3/day.
print(f"The influent flow rate is {Q:.2f} m3/day \n")
N_inf = 30 # Influent N concentration, mg/L.
BOD_inf = 300 # Influent BOD concentration, mg/L.

# Effluent wastewater charcateristics
N_eff =  6 # Effluent N concentration, mg/L.
BOD_eff = 100 # Effluent BOD concentration, mg/L.

# Bioreactor parameters
SWD_tank = 6 # Side water depth of bioreactor tanks, m. Varies between 4.5-7.5.
t_w = 0.3 # Thickness of wall, m.
t_s = 0.35 # Thickness of slab, m.
FB = 0.5 # Freeboard, m. Varies 0.3-0.6.
W_to_D = 1.5 # Width:depth. Varies from 1-2.2.
SOTE = 15 # Oxygen transfer efficiency in %. Varies between 6-15.

# Secondary clarifier parameters
SOR = 28 # Surface overflow rate, m3/day/m2. Varies between 24-32.

# Sludge characteristics
w_sl_solids = 98.0 # Weight of sludge solids, kg/ 1000 m3. Varies between 82-130.
# print(f"The wastage rate is {WAS:.2f} m3/day \n")
SG_sludge = 1.05 # Specific gravity of sludge, to calculate WAS pump power.

# Pump parameters
r = 0.75 # Recycle ratio for RAS. Varies 0.5-0.75.
rho_water = 1000 # Density of water, kg/m3.
g = 9.81 # m/s2.
pump_effic = 0.675 # As decimal. Varies 0.6-0.75.
H_pump = 0.3 # Static head, m.
ir = 1.5 # Internal recycle ratio.
print(f"The internal recycle flow rate is {ir * Q:.2f} m3/day \n")
op_hours = 8760 # Operating hours, assuming 24 hours of operation per day, for 365 days.

# Methanol parameters
SG_methanol = 0.7917 # Specific gravity of methanol at 20 C.

# Blower constants abd parameters
C = 28.97 # Molecular weight of dry air
R = 8.314  # Engineering gas constant for air, in J/mol K.
T1 = 20 # Temperature, degrees Celcius.
P2 = 1.532 # atm, atmospheric temperature + water pressure.
P1 = 1 # atm, atmospheric temperature.
n = 0.283  # (k-1)/k for air.
rho_air = 1.204 # Density of air at 20 C, kg/m3.
blower_effic = 0.80 # As decimal. Varies 0.7-0.9.

# Denitrification filter parameters
n_filters = 5 # Number of denitrification filter tanks, 1 standby
HAR = 4 # Hydraulic application rate, varies from 2.4-4.8,  m/hr.
water_backwash_rate = 18 # Water backwash rate per backwash, m3/hr/m2.
air_backwash_rate = 90 # Air backwash rate per backwash, m3/hr/m2.
backwash_duration = 15 # Duration of backwash per backwash, mins.
backwash_freq = 1 # Number of backwash per day per filter.
bump_water_flush_rate = 12 # m3/m2/hr.
bump_water_duration = 4 # mins per bump.
bump_water_freq = 1 # Number of bumps every 3 hours per filter.

# Cost calculation constants
interest_rate = 0.05 # Discount rate, varies between 4-6%
project_lifetime = 50 # Design life of the system, years.
mech_lifetime = 15 # Lifetime of pumps and blowers, years.

'''
units = {
      'Volume of tank': 'm3',
      'Volume of clarifier': 'm3',
      'Area of clarifier': 'm2',
      'Area of filter': 'm2'
      'Volume of wall concrete': 'm3',
      'Volume of slab concrete': 'm3',
      'Amount of reinforcing steel': 'kg',
      'Area of slab': 'm2',
      'Pump power': 'kW',
      'Blower power': 'KW',
      'Pipe length': 'm',
      'Sludge solids': 'kg',
      'Methanol': 'kg'
      }
'''

unit_costs = {
    'wall_conc': 400.23, # $/m3
    'slab_conc': 93.27, # $/m2
    'steel': 1.73, # $/kg
    'methanol': 0.3465, # $/kg
    'electricity': 0.09561, # $/kWh
    'solid_management': 0.55, # $/kg
    'filter_media': 47.96, # $/m3
    'filter_support': 44.54, # $/m3
    'pipe': 40/3.28, # $/m
    'pump': 5000, # each
    'blower': 7000 # each
}

# Impact calculation constants
density_of_supporting_media = 1800
density_of_filter_media = 1600
density_of_concrete = 2400
density_of_steel = 7850
transportation_distance = 50 # Assuming a transportation distance of 50 km

unit_impacts = {
    'wall_concrete': 579.243, # kg CO2-eq/m3
    'slab_concrete': 390.285, # kg CO2-eq/m2
    'pipe': 3.569, # kg CO2-eq/m
    'dnf_media': 0.022, # kg CO2-eq/kg
    'transport': 1.077, # kg CO2-eq/ton/km
    'electricity': 0.561, # kg CO2-eq/kWh
    'methanol': 1.259, # kg CO2-eq/kg
    'n2O_emission_B': 0.0036 * 1.571 * 265, # Conversion from kg N2O-N/kg N to kg CO2-eq/kg N
    'n2O_emission_M': 0.00065 * 1.571 * 265, # Conversion from kg N2O-N/kg N to kg CO2-eq/kg N
    'land application of sludge': 0.010 * 1.571 * 265, # Conversion from kg N2O-N/kg N to kg CO2-eq/kg N
    'methane_emissions': 0.018 * 28 # Conversion from kg CH4/kg BOD to kg CO2-eq/kg BOD
}

# Estimating backwash and bump water requirements for denitrification filter
def filter(a, HAR, phase=''):
  air_flowrate = air_backwash_rate * a # Backwash air flowrate per filter, m3/hr.
  water_flowrate = water_backwash_rate * a # Backwash water flowrate per filter, m3/hr.
  vol_backwash_water = water_flowrate * backwash_duration * (n_filters-1) * backwash_freq/60 # Total volume for backwash water required, for backwashing 4 filters for 15 mins once every day, m3/day.
  vol_bump_water = a * (n_filters-1) * bump_water_flush_rate * bump_water_duration * bump_water_freq * 24/60 # Total volume of bump water required, for bumping 4 filter for 4 mins, once every 3 hours, m3/day.
  if phase == 'w': return round(vol_backwash_water + vol_bump_water, 2)
  elif phase =='a': return round(air_flowrate, 2)

# Computing concrete and steel requirements for each unit
def const_mat(ID='', L=0., W=0., SWD=0., d=0., s=0.):

# For anoxic and aerobic zones
    if L !=0. :
        V_sw = 2 * W * t_w * (SWD + FB)
        V_lw = 2 * (L + 2*t_w) * t_w * (SWD+FB)
        V_c_s = V_s = (L + 2*t_w) * (W + 2*t_w) * t_s
        V_c_w = V_sw + V_lw
        V_c_t = V_c_s + V_c_w
        M_steel = 77.58 * V_c_t
        return V_c_w, V_c_s, M_steel

# For secondary clarifier
    elif d !=0. :
        V_c_w = V_cy = pi * ((d + 2*t_w)**2 - d**2) * (FB + SWD)/4
        V_c_s = V_s = pi * (d + 2*t_w)**2 * t_s/4
        V_c_t = V_c_s + V_c_w
        M_steel = 77.58 * V_c_t
        return V_c_w, V_c_s, M_steel

#For denitrification tank
    elif s !=0. :
        V_c_w = V_w = 4 * (s + t_w) * t_w * (SWD + FB)
        V_c_s = V_s = (s + 2*t_w)**2 * t_s
        V_c_t = V_c_s + V_c_w
        M_steel = 77.58 * V_c_t
        return V_c_w, V_c_s, M_steel

# Computing dimensions of each unit
def dimension(conf='', ID='', L_to_W=5):
  if ID.startswith('a'):
    if conf == 'MLE':
      if ID == 'anoxic': HRT = 1
      elif ID == 'aerobic': HRT = 6
    elif conf == 'Bardenpho':
      if ID == 'anoxic_1': HRT = 3
      elif ID == 'aerobic_1': HRT = 15.5
      elif ID == 'anoxic_2': HRT = 2
      elif ID == 'aerobic_2': HRT = 0.5
    V = Q * HRT/24
    A = V/SWD_tank
    W = W_to_D * SWD_tank
    L = max(A/W, L_to_W * W)
    if conf == 'MLE': MLE['pipe'] += 2 * 2 * L # 2L is to account for IR pipe (aerobic to anoxic) and RAS (clarifier to anoxic) pipe. x2 accounts for the redundant train.
    elif conf == 'Bardenpho':
      if ID == 'anoxic_1' or ID == 'aerobic_1': Bardenpho['pipe'] += 2 * 2 * L # 2L is to account for IR pipe (aerobic_1 to anoxic_1) and RAS (clarifier to anoxic) pipe. x2 accounts for the redundant train.
      else: Bardenpho['pipe'] += 2 * L # To account for RAS pipe for the 2nd anoxic-aerobic zones. x2 accounts for the redundant train.
    V_c_w, V_c_s, M_steel = const_mat(L=L, W=W, SWD=SWD_tank)
    return round(V,2), round(2*V_c_w,2), round(2*V_c_s,2), round(2*M_steel,2)

  elif ID.startswith('c'):
    A = Q/SOR
    d = mt.sqrt(4 * A/pi)
    if conf == 'MLE': MLE['pipe'] += 2 * d/2 # To account for RAS pipe starting from bottom of the clarifier center. x2 accounts for the redundant train.
    elif conf == 'Bardenpho': Bardenpho['pipe'] += 2 * d/2 # To account for RAS pipe starting from bottom of the clarifier center. x2 accounts for the redundant train.
    if d <= 21: SWD = 3.7
    elif d > 21 and d <= 30: SWD = 4
    elif d > 30 and d <= 43: SWD = 4.3
    elif d > 43: SWD = 4.6
    V_c_w, V_c_s, M_steel = const_mat(d=d, SWD=SWD)
    V = A * SWD
    return round(V,2), round(2*V_c_w,2), round(2*V_c_s,2), round(2*M_steel,2)

  elif ID.startswith('d'):
    SWD = 0.45 + 2 + 1.53 # supporting media + fitler media + hydraulic head, m.
    A = Q/(24 * HAR)
    a = A/(n_filters-1)
    L = mt.sqrt(a)
    V_c_w, V_c_s, M_steel = const_mat(s=L, SWD=SWD)
    MLE['denitrification tank']['A_total'] = round(a*n_filters, 2)
    return round(a,2), round(n_filters*V_c_w,2), round(n_filters*V_c_s,2), round(n_filters*M_steel,2)

# Estimating pump power
def pump_power(Q, ratio):
  return (Q * ratio * rho_water * g * H_pump)/(24 * 60 * 60 * pump_effic * 1000)

def pump(pump_config):
  if pump_config == 'MLE':
    ir_pump_power = pump_power(Q, ir)
    r_pump_power = pump_power(Q, r)
    Q_bw = filter(MLE['denitrification tank']['a_single'], HAR, phase='w')
    bw_pump_power = pump_power(Q_bw, 1)
    was_pump_power = pump_power(WAS, SG_sludge)
    meth_pump_power = pump_power(Q_methanol, SG_methanol)
    return round(ir_pump_power,2), round(r_pump_power,2), round(bw_pump_power,2), round(was_pump_power,2), round(meth_pump_power,2)

  elif pump_config == 'Bardenpho':
    ir_pump_power = pump_power(Q, ir)
    r_pump_power = pump_power(Q, r)
    was_pump_power = pump_power(WAS, SG_sludge)
    meth_pump_power = pump_power(Q_methanol, SG_methanol)
    return round(ir_pump_power,2), round(r_pump_power,2), round(was_pump_power,2), round(meth_pump_power,2)

# Estimating blower power
def blower(air_flow):
  air_flow = air_flow * rho_air
  blower_power = ((P2/P1)**n - 1) * air_flow * 8.314 * T1 / (28.97 * n * blower_effic)
  blower_power = round(blower_power, 2)
  return round(blower_power, 2)

# Estimating the weight of sludge solids produced daily
def solids(weight, rate):
  solids = round(weight * rate/1000, 2) # Mass of solids in kg.
  return solids

def calculate_total_amounts(system_name, system, amounts):
    for key in system:
        if key not in {'pumps', 'pipe', 'blowers', 'sludge solids'}:
            amounts['V_c_w'] += system[key]['V_c_w']
            amounts['V_c_s'] += system[key]['V_c_s']
            amounts['M_steel'] += system[key]['M_steel']
            amounts['A_slab'] += system[key]['A_slab']
        if key == 'pumps':
            amounts['num_pumps'] = len(system[key])
            amounts['num_pumps_const'] = len(system[key])
            for pump in system[key]:
                if pump != 'bw_power':
                    amounts['num_pumps_const'] += 1
        if key == 'blowers':
            amounts['num_blowers'] = len(system[key])
            amounts['num_blowers_const'] = len(system[key])
            for blower in system[key]:
                if blower != 'dnf_blower':
                    amounts['num_blowers_const'] += 1

    amounts['solid_management'] = 365 * system["sludge solids"]
    amounts['methanol'] += Q_methanol * SG_methanol * rho_water * 365
    amounts['pipe'] += system['pipe']

    for key in system['pumps']:
        amounts['electricity'] += op_hours * system['pumps'][key]
    for key in system['blowers']:
        amounts['electricity'] += op_hours * system['blowers'][key]

    if system_name == 'MLE':
        amounts['filter_media'] = system['denitrification tank']['a_single'] * n_filters * 2
        amounts['filter_support'] = system['denitrification tank']['a_single'] * n_filters * .45
        amounts['electricity'] += op_hours * system['pumps']['bw_power']

def calculate_impacts(data, config_type):
    total_hours = 24 * 365
    n2o_emission_factor = unit_impacts['n2O_emission_M'] if config_type == 'MLE' else unit_impacts['n2O_emission_B']

    construction_impact = {
        'wall_concrete': data['V_c_w'] * unit_impacts['wall_concrete'],
        'slab_concrete': data['A_slab'] * unit_impacts['slab_concrete'],
        'pipe': data['pipe'] * unit_impacts['pipe'],
        'dnf_filter_media': data.get('filter_media', 0) * density_of_filter_media * unit_impacts['dnf_media'],
        'dnf_supporting_media': data.get('filter_support', 0) * density_of_supporting_media * unit_impacts['dnf_media'],
        'transport': ((data['V_c_w'] + data['V_c_s']) * density_of_concrete + data['M_steel'] * density_of_steel) / 1000 * unit_impacts['transport'] * transportation_distance
    }

    operation_impact = {
        'electricity': data['electricity'] * unit_impacts['electricity'] * total_hours,
        'transportation_Sludge': data['solid_management'] / 1000 * transportation_distance * unit_impacts['transport'] * 365,
        'land_application_sludge': data['solid_management'] * unit_impacts['land application of sludge'],
        'methanol': data['methanol'] * unit_impacts['methanol'],
        'N2O_emission': (N_inf - N_eff) * Q / 1000 * 365 * n2o_emission_factor,
        'methane_emissions': (BOD_inf - BOD_eff) * Q / 1000 * unit_impacts['methane_emissions'] * 365
    }

    return {'construction': construction_impact, 'operation': operation_impact}

# Function to Calculate Total Impact
def calculate_total_impact(impacts):
    total_impact = {
        'MLE': {
            'total_construction': round(sum(impacts['MLE']['construction'].values()),2),
            'total_operation': round(sum(impacts['MLE']['operation'].values()),2)
        },
        'Bardenpho': {
            'total_construction': round(sum(impacts['Bardenpho']['construction'].values()),2),
            'total_operation': round(sum(impacts['Bardenpho']['operation'].values()),2)
        },
    }
    return total_impact

MLE_sizings = {}
Bardenpho_sizings = {}

for design in MLE_design_comb:
  DO, WAS, Q_methanol = design
  MLE = {
      'anoxic': {'V': 0., 'V_c_w': 0., 'V_c_s': 0., 'M_steel': 0., 'A_slab':0.},
      'aerobic': {'V': 0., 'V_c_w': 0., 'V_c_s': 0., 'M_steel': 0., 'A_slab':0.},
      'clarfier': {'V': 0., 'V_c_w': 0., 'V_c_s': 0., 'M_steel': 0., 'A_slab':0.},
      'denitrification tank': {'a_single': 0., 'V_c_w': 0., 'V_c_s': 0., 'M_steel': 0., 'A_slab':0., 'A_total':0.,},
      'pumps': {'ir_power': 0., 'r_power': 0., 'bw_power': 0., 'WAS_power': 0., 'meth_power': 0.},
      'pipe': 0.,
      'blowers': {'rx_blower': 0., 'dnf_blower': 0.},
      'sludge solids': 0.
  }

  for key in MLE:
    if key.startswith('a') or key.startswith('c'):
      MLE[key]['V'], MLE[key]['V_c_w'], MLE[key]['V_c_s'], MLE[key]['M_steel'] = dimension(conf='MLE', ID=key)
    elif key.startswith('d'):
      MLE[key]['a_single'], MLE[key]['V_c_w'], MLE[key]['V_c_s'], MLE[key]['M_steel'] = dimension(ID = key)
    elif key == 'pumps': MLE[key]['ir_power'], MLE[key]['r_power'], MLE[key]['bw_power'], MLE[key]['WAS_power'], MLE[key]['meth_power'] = pump('MLE')
    elif key == 'blowers':
      RO = DO * Q/ (24 * 1000) # Required dissolved oxygen, converted to kg/hr.
      Q_air_rx = 6 * RO/SOTE # Required airflow rate, m3/s.
      MLE[key]['rx_blower'] = blower(Q_air_rx)
      Q_air_bw = filter(MLE['denitrification tank']['a_single'], HAR, phase='a')/ (24 * 60 * 60) # Backwash air flowrate in m3/s.
      MLE[key]['dnf_blower'] = blower(Q_air_bw)
    elif key == 'sludge solids':
      MLE[key] = solids(w_sl_solids, WAS)

  for key in MLE:
    if isinstance(MLE[key], dict):
      if MLE[key].get('V_c_s', None):
        MLE[key]['A_slab'] = round(MLE[key]['V_c_s']/t_s, 2)

  MLE['pipe'] *= 1.25 # Adding 25% to pipe length.
  MLE['pipe'] = round(MLE['pipe'], 2)

  MLE_sizings[design] = MLE

for design in Bardenpho_design_comb:
  DO, WAS, Q_methanol = design
  Bardenpho = {
        'anoxic_1': {'V': 0., 'V_c_w': 0., 'V_c_s': 0., 'M_steel': 0., 'A_slab':0.},
        'aerobic_1': {'V': 0., 'V_c_w': 0., 'V_c_s': 0., 'M_steel': 0., 'A_slab':0.},
        'anoxic_2': {'V': 0., 'V_c_w': 0., 'V_c_s': 0., 'M_steel': 0., 'A_slab':0.},
        'aerobic_2': {'V': 0., 'V_c_w': 0., 'V_c_s': 0., 'M_steel': 0., 'A_slab':0.},
        'clarifier': {'V': 0., 'V_c_w': 0., 'V_c_s': 0., 'M_steel': 0., 'A_slab':0.},
        'pumps': {'ir_power': 0., 'r_power': 0., 'WAS_power':0., 'meth_power': 0.},
        'pipe': 0.,
        'blowers': {'rx_blower': 0.},
        'sludge solids': 0.
  }

  for key in Bardenpho:
    if key.startswith('a') or key.startswith('c'):
      Bardenpho[key]['V'], Bardenpho[key]['V_c_w'], Bardenpho[key]['V_c_s'], Bardenpho[key]['M_steel'] = dimension('Bardenpho', key)
    elif key == 'pumps': Bardenpho[key]['ir_power'], Bardenpho[key]['r_power'], Bardenpho[key]['WAS_power'], Bardenpho[key]['meth_power']  = pump('Bardenpho')
    elif key == 'blowers':
      RO = DO * Q/ (24 * 1000) # Required dissolved oxygen, converted to kg/hr.
      Q_air_rx = 6 * RO/SOTE # Required airflow rate, m3/s.
      Bardenpho[key]['rx_blower'] = blower(Q_air_rx)
    elif key == 'sludge solids':
      Bardenpho[key] = solids(w_sl_solids, WAS)

  for key in Bardenpho:
    if isinstance(Bardenpho[key], dict):
      if Bardenpho[key].get('V_c_s', None):
        Bardenpho[key]['A_slab'] = round(Bardenpho[key]['V_c_s']/t_s, 2)

  Bardenpho['pipe'] *= 1.25 # Adding 25% to pipe length.
  Bardenpho['pipe'] = round(Bardenpho['pipe'], 2)

  Bardenpho_sizings[design] = Bardenpho

print("--------------------------MLE DESIGNS--------------------------")
for design in MLE_sizings:
  print("(DO, WAS, Methanol): ", design)
  for size in MLE_sizings[design]: print(size, ':', MLE_sizings[design][size])
  print('\n')

print("--------------------------BARDENPHO DESIGNS--------------------------")
for design in Bardenpho_sizings:
  print("(DO, WAS, Methanol): ", design)
  for size in Bardenpho_sizings[design]: print(size, ':', Bardenpho_sizings[design][size])
  print('\n')

AN_given_PV_factor = interest_rate * (interest_rate * (1 + interest_rate) ** project_lifetime) / ((1 + interest_rate) ** project_lifetime - 1)

total_costs = {'MLE':{}, 'Bardenpho':{}}
total_amounts = {'MLE':{}, 'Bardenpho':{}}

def calculate_capital_cost(amounts, unit_costs):
    capital_cost_PV = unit_costs['wall_conc'] * amounts['V_c_w']
    capital_cost_PV += unit_costs['slab_conc'] * amounts['A_slab']
    capital_cost_PV += unit_costs['steel'] * amounts['M_steel']
    capital_cost_PV += unit_costs['pipe'] * amounts['pipe']
    capital_cost_PV += unit_costs['pump'] * amounts['num_pumps']
    capital_cost_PV += unit_costs['blower'] * amounts['num_blowers']
    if 'filter_media' in amounts:
        capital_cost_PV += unit_costs['filter_media'] * amounts['filter_media']
        capital_cost_PV += unit_costs['filter_support'] * amounts['filter_support']
    return capital_cost_PV

def calculate_replacement_cost(amounts, unit_costs, yr):
    replace_cost_PV = unit_costs['pump'] * amounts['num_pumps'] * (1 + interest_rate) ** -yr
    replace_cost_PV += unit_costs['blower'] * amounts['num_blowers'] * (1 + interest_rate) ** -yr
    return replace_cost_PV

def calculate_operating_cost(amounts, unit_costs):
    operate_cost = unit_costs['methanol'] * amounts['methanol']
    operate_cost += unit_costs['electricity'] * amounts['electricity']
    operate_cost += unit_costs['solid_management'] * amounts['solid_management']
    return operate_cost


for design in MLE_design_comb:
    DO, WAS, Q_methanol = design
    MLE_amounts = {
        'V_c_w': 0., 'V_c_s': 0., 'A_slab': 0., 'M_steel': 0., 'methanol': 0.,
        'electricity': 0, 'solid_management': 0., 'filter_media': 0,
        'filter_support': 0., 'pipe': 0., 'num_pumps': 0, 'num_pumps_const': 0,
        'num_blowers': 0, 'num_blowers_const': 0
    }
    calculate_total_amounts('MLE', MLE_sizings[design], MLE_amounts)
    MLE_amounts = {k: round(v, 2) for k, v in MLE_amounts.items()}

    # Calculating costs
    capital_cost_PV = calculate_capital_cost(MLE_amounts, unit_costs)
    capital_cost_AN = capital_cost_PV * AN_given_PV_factor
    replacement_cost_AN = 0
    for yr in range(mech_lifetime, project_lifetime, mech_lifetime):
        replace_cost_PV = calculate_replacement_cost(MLE_amounts, unit_costs, yr)
        replacement_cost_AN += replace_cost_PV * AN_given_PV_factor
    operating_cost = calculate_operating_cost(MLE_amounts, unit_costs)
    total_costs['MLE'][design] = {
        'capital_cost': round(capital_cost_AN, 2),
        'replacement_cost': round(replacement_cost_AN, 2),
        'operating_cost': round(operating_cost, 2)
    }
    total_amounts['MLE'][design] = MLE_amounts


for design in Bardenpho_design_comb:
    DO, WAS, Q_methanol = design
    Bardenpho_amounts = {
        'V_c_w': 0., 'V_c_s': 0., 'A_slab': 0., 'M_steel': 0., 'methanol': 0.,
        'electricity': 0, 'solid_management': 0., 'pipe': 0., 'num_pumps': 0,
        'num_pumps_const': 0, 'num_blowers': 0, 'num_blowers_const': 0
    }
    calculate_total_amounts('Bardenpho', Bardenpho_sizings[design], Bardenpho_amounts)
    Bardenpho_amounts = {k: round(v, 2) for k, v in Bardenpho_amounts.items()}
    # Calculating costs
    capital_cost_PV = calculate_capital_cost(Bardenpho_amounts, unit_costs)
    capital_cost_AN = capital_cost_PV * AN_given_PV_factor
    replacement_cost_AN = 0
    for yr in range(mech_lifetime, project_lifetime, mech_lifetime):
        replace_cost_PV = calculate_replacement_cost(Bardenpho_amounts, unit_costs, yr)
        replacement_cost_AN += replace_cost_PV * AN_given_PV_factor
    operating_cost = calculate_operating_cost(Bardenpho_amounts, unit_costs)
    total_costs['Bardenpho'][design] = {
        'capital_cost': round(capital_cost_AN, 2),
        'replacement_cost': round(replacement_cost_AN, 2),
        'operating_cost': round(operating_cost, 2)
    }
    total_amounts['Bardenpho'][design] = Bardenpho_amounts

for system in total_costs:
    for design in total_costs[system]:
        print(f"\nSystem: {system}")
        print(f"Decision variables: {design}")
        print(f"Amounts: {total_amounts[system][design]}")
        print(f"Costs: {total_costs[system][design]}")

"""Construction phase: volume of wall concrete, area of slab, reinforcing steel, Pumps and blowers, pipe, filter and supporting media.

Operation phase: methanol, electricity, maintenance, solids management
"""

# Initialize dictionary to store impacts
total_impacts = {'MLE': {}, 'Bardenpho': {}}


for design in MLE_design_comb:
    DO, WAS, Q_methanol = design
    amounts = total_amounts['MLE'][design]
    MLE_impacts = calculate_impacts(amounts, 'MLE')
    total_impacts['MLE'][design] = {
        'construction': {k: round(v, 2) for k, v in MLE_impacts['construction'].items()},
        'operation': {k: round(v, 2) for k, v in MLE_impacts['operation'].items()},
        'total_construction': round(sum(MLE_impacts['construction'].values()), 2),
        'total_operation': round(sum(MLE_impacts['operation'].values()), 2)
    }


for design in Bardenpho_design_comb:
    DO, WAS, Q_methanol = design
    amounts = total_amounts['Bardenpho'][design]
    Bardenpho_impacts = calculate_impacts(amounts, 'Bardenpho')
    total_impacts['Bardenpho'][design] = {
        'construction': {k: round(v, 2) for k, v in Bardenpho_impacts['construction'].items()},
        'operation': {k: round(v, 2) for k, v in Bardenpho_impacts['operation'].items()},
        'total_construction': round(sum(Bardenpho_impacts['construction'].values()), 2),
        'total_operation': round(sum(Bardenpho_impacts['operation'].values()), 2)
    }

for system in total_impacts:
    print(f"\nResults for {system} Configuration:")
    print("-" * 50)
    for design in total_impacts[system]:
        print(f"(DO, WAS, Q_methanol): {design}")
        print("Construction Impacts:")
        for category, value in total_impacts[system][design]['construction'].items():
            print(f"{category}: {value}")
        print(f"Total Construction Impact: {total_impacts[system][design]['total_construction']}")

        print("\nOperation Impacts:")
        for category, value in total_impacts[system][design]['operation'].items():
            print(f"{category}: {value}")
        print(f"Total Operation Impact: {total_impacts[system][design]['total_operation']}")

        total = total_impacts[system][design]['total_construction'] + total_impacts[system][design]['total_operation']
        print(f"\nTotal Combined Impact: {round(total, 2)}")
        print("-" * 50)

for decision_set in total_costs:
  print(decision_set)
  print("cost: ", total_costs[decision_set])
  print("impact: ", total_impacts[decision_set], "\n")

# Initialize lists to store data for plotting
mle_costs = []
mle_impacts = []
bardenpho_costs = []
bardenpho_impacts = []

# Extract the data for MLE
for design in total_costs['MLE']:
    mle_total_cost = (total_costs['MLE'][design]['capital_cost'] +
                      total_costs['MLE'][design]['replacement_cost'] +
                      total_costs['MLE'][design]['operating_cost'])
    mle_total_impact = (total_impacts['MLE'][design]['total_construction'] +
                        total_impacts['MLE'][design]['total_operation'])
    mle_costs.append(mle_total_cost/10E3)
    mle_impacts.append(mle_total_impact/10E6)

# Extract the data for Bardenpho
for design in total_costs['Bardenpho']:
    bardenpho_total_cost = (total_costs['Bardenpho'][design]['capital_cost'] +
                           total_costs['Bardenpho'][design]['replacement_cost'] +
                           total_costs['Bardenpho'][design]['operating_cost'])
    bardenpho_total_impact = (total_impacts['Bardenpho'][design]['total_construction'] +
                             total_impacts['Bardenpho'][design]['total_operation'])
    bardenpho_costs.append(bardenpho_total_cost/10E3)
    bardenpho_impacts.append(bardenpho_total_impact/10E6)

# Create scatter plot for MLE and Bardenpho
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10, 5))

ax1.scatter(mle_impacts, mle_costs, color='blue')
ax1.set_title('Cost vs Impact for MLE')
ax1.set_ylabel('Total Cost (Thousand USD/year)')
ax1.set_xlabel('Total Impact (Million kg CO2 equivalent)')
ax1.legend()

ax2.scatter(bardenpho_impacts, bardenpho_costs, color='green')
ax2.set_title('Cost vs Impact for Bardenpho')
ax2.set_ylabel('Total Cost (Thousand USD/year)')
ax2.set_xlabel('Total Impact (Million kg CO2 equivalent)')
ax2.legend()

# Display the plots
plt.tight_layout()
plt.show()

# Function to find Pareto optimal points
def pareto_frontier(costs, impacts):
    is_pareto = np.ones(len(costs), dtype=bool)  # Initialize all points as part of Pareto frontier

    for i in range(len(costs)):
        for j in range(len(costs)):
            if i != j:
                # Check if point j dominates point i (strictly lower cost and impact)
                if costs[j] <= costs[i] and impacts[j] <= impacts[i] and (costs[j] < costs[i] or impacts[j] < impacts[i]):
                    is_pareto[i] = False  # i is not Pareto optimal

    return is_pareto

# Offset for annotations to avoid overlap
offset = 4

# Get Pareto optimal points for MLE
mle_is_pareto = pareto_frontier(mle_costs, mle_impacts)

# Get Pareto optimal points for Bardenpho
bardenpho_is_pareto = pareto_frontier(bardenpho_costs, bardenpho_impacts)

# Create scatter plot for MLE and Bardenpho
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10, 5))

# MLE scatter plot
ax1.scatter(mle_impacts, mle_costs, color='blue', label='MLE')
ax1.set_title('Cost vs Impact for MLE')
ax1.set_ylabel('Total Cost (Thousand USD/year)')
ax1.set_xlabel('Total Impact (Million kg CO2 equivalent)')
ax1.legend()

# Annotate Pareto optimal points for MLE with costs and impacts, avoiding overlap
for i in range(len(mle_costs)):
    if mle_is_pareto[i]:
        label = MLE_design_comb[i]
        ax1.annotate(label, (mle_impacts[i], mle_costs[i]),
                     textcoords="offset points", xytext=(offset, offset), fontsize=8, color='blue')

# Bardenpho scatter plot
ax2.scatter(bardenpho_impacts, bardenpho_costs, color='green', label='Bardenpho')
ax2.set_title('Cost vs Impact for Bardenpho')
ax2.set_ylabel('Total Cost (Thousand USD/year)')
ax2.set_xlabel('Total Impact (Million kg CO2 equivalent)')
ax2.legend()

# Annotate Pareto optimal points for Bardenpho with costs and impacts, avoiding overlap
for i in range(len(bardenpho_costs)):
    if bardenpho_is_pareto[i]:
        label = Bardenpho_design_comb[i]
        ax2.annotate(label, (bardenpho_impacts[i], bardenpho_costs[i]),
                     textcoords="offset points", xytext=(offset, offset), fontsize=8, color='green')

# Display the plots
plt.tight_layout()
plt.show()

"""Plots:
1. Scenario comparison for MLE and Bardenpho. To pick top 1-2 designs overall.
  kernel and/or box-whisker (OR) Scatter plot
2. Uncertainty analysis for other parameters.
"""

